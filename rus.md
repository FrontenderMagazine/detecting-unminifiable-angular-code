# Обнаружение неминифицируемого Angular кода

Когда вы пишете Angular-компоненты, например, контроллеры, сервисы или директивы, вы можете указать все зависимости, которые необходимы для работы. Инъекция Angular потом будет разрешать их и делать доступными для вашего компонента.

Самый простой путь указать зависимости — это назвать аргументы фабричного метода или конструктора вашего компонента так же, как называются требуемые компоненты:

    angular
        .module("someModule")
        .factory("someService", function($http, $q) {
            // ...
        });

Но при таком подходе есть один недостаток: инъекция зависимостей разрешит их, основываясь на именах аргументов, но такое решение **не работает с минифицированным кодом**. В этом случае параметры обычно сокращают до однобуквенных переменных, тем самым делая невозможным использование их имён для разрешения зависимостей.

Angular предлагает решение этой проблемы. Если указать имена зависимостей явно, в виде строк, а не полагаться на точное совпадение имён аргументов, ваши компоненты станут **безопасно минифицируемыми**. Просто нужно будет убедиться, что порядок строк соответствует порядку параметров в методе фабрики или функции конструктора:

    angular
        .module("someModule")
        .factory("someService", ["$http", "$q", function($http, $q) {
            // ...
        }]);

Вместо того, чтобы явно прописывать массив, вы можете использовать функцию со свойством `$inject`, которая просто позволит записать массив зависимости имен. Я предпочитаю использовать этот синтаксис:

    angular
        .module("someModule")
        .factory("someService", someService);
     
    someService.$inject = ["$http", "$q"];
     
    function someService($http, $q) {
        // ...
    }

Так или иначе, код теперь может быть минифицирован без проблем. Но оба подхода имеют недостаток. То, что код не работает становится ясно только после того, как вы его минифицируете, выполните или запустите разрешение зависимостей. Было бы лучше, если бы код падал **сразу**.

Для этого можно использовать атрибут `ng-strict-di`, который заставит Angular работать именно так. Атрибут добавляется непосредственно элементу приложения:

    <html ng-app="someModule" ng-strict-di>
        <!-- ... -->
    </html>

Вот что говорится в [документации по Angular][1]:

> Если у элемента приложения есть этот атрибут, инжектор будет создан в режиме `ng-strict-di`. Это означает, что приложение не сможет вызывать функции, которые явно не используют аннотацию функций (и, таким образом, непригодны для минификации), как описано в [справочнике Инъекции Зависимости][2], и полезная отладочная информация будет помогать в поиске корня этих ошибок.

Использование строгого режима инъекции зависимостей позволяет обнаружить, что компонента Angular непригодна для минификации без попытки самой минификации кода. Стоит добавить `ng-strict-di` к вашему элементу приложения, если вы этого еще не сделали!

 [1]: https://docs.angularjs.org/api/ng/directive/ngApp
 [2]: https://docs.angularjs.org/guide/di
 [3]: https://twitter.com/share
